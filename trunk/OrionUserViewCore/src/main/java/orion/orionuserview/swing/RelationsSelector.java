/*
 * RelationsSelector.java
 *
 * Created on Oct 7, 2010, 6:54:49 PM
 */
package orion.orionuserview.swing;

import java.awt.Color;
import java.awt.Component;
import java.awt.FlowLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.Serializable;
import java.sql.SQLException;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.AbstractCellEditor;
import javax.swing.ButtonGroup;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JTable;
import javax.swing.UIManager;
import javax.swing.border.Border;
import javax.swing.border.EmptyBorder;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import org.jdesktop.application.Action;
import org.jdesktop.application.Application;
import org.jdesktop.application.ResourceMap;
import orion.orionuserview.Relation;
import orion.orionuserview.RelationSourceType;
import orion.orionuserview.RelationType;

/**
 *
 * @author sl
 */
public class RelationsSelector extends javax.swing.JPanel {

    private Globals globals;
    private static final ResourceMap resourceMap = Application.getInstance().getContext().getResourceMap(SimpleConnectionSelector.class);
    private DefaultTableModel model = new javax.swing.table.DefaultTableModel(
            null,
            new String[]{"Таблица", "U      E      P      G       I       R      H"}) {

        Class[] types = new Class[]{Relation.class, Relation.class};

        @Override
        public Class getColumnClass(int columnIndex) {
            return types[columnIndex];
        }
    };

    /** Creates new form RelationsSelector */
    public RelationsSelector(Globals globals) {
        this.globals = globals;
        initComponents();
        relationsTable.setDefaultEditor(Relation.class, new RelationCellEditor(globals));
        relationsTable.setDefaultRenderer(Relation.class, new RelationCellRenderer(globals));
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        relationsTable = new javax.swing.JTable();
        jToolBar1 = new javax.swing.JToolBar();
        jButton1 = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JToolBar.Separator();
        jButton2 = new javax.swing.JButton();
        jSeparator2 = new javax.swing.JToolBar.Separator();
        jButton3 = new javax.swing.JButton();

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });

        jScrollPane1.setName("jScrollPane1"); // NOI18N

        relationsTable.setModel(model);
        relationsTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
        relationsTable.setName("relationsTable"); // NOI18N
        relationsTable.getTableHeader().setReorderingAllowed(false);
        jScrollPane1.setViewportView(relationsTable);

        jToolBar1.setFloatable(false);
        jToolBar1.setName("jToolBar1"); // NOI18N

        javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance().getContext().getActionMap(RelationsSelector.class, this);
        jButton1.setAction(actionMap.get("forecastOne")); // NOI18N
        jButton1.setText("Предположение первое");
        jButton1.setActionCommand("Предположение первое");
        jButton1.setFocusable(false);
        jButton1.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton1.setName("jButton1"); // NOI18N
        jButton1.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar1.add(jButton1);

        jSeparator1.setName("jSeparator1"); // NOI18N
        jToolBar1.add(jSeparator1);

        jButton2.setAction(actionMap.get("forecast2")); // NOI18N
        jButton2.setFocusable(false);
        jButton2.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton2.setName("jButton2"); // NOI18N
        jButton2.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar1.add(jButton2);

        jSeparator2.setName("jSeparator2"); // NOI18N
        jToolBar1.add(jSeparator2);

        jButton3.setAction(actionMap.get("forecastThree")); // NOI18N
        jButton3.setFocusable(false);
        jButton3.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButton3.setName("jButton3"); // NOI18N
        jButton3.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar1.add(jButton3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 581, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 291, javax.swing.GroupLayout.PREFERRED_SIZE))
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        globals.addHint("Сделайте первое предположение");
        fillTable();
    }//GEN-LAST:event_formComponentShown
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JToolBar.Separator jSeparator1;
    private javax.swing.JToolBar.Separator jSeparator2;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JTable relationsTable;
    // End of variables declaration//GEN-END:variables

    private void fillTable() {
        try {
            List<Relation> relations = new ArrayList(globals.getDatabaseDef().getRelations());
            Collections.sort(relations, new Comparator<Relation>() {

                @Override
                public int compare(Relation o1, Relation o2) {
                    return UIUtils.relationPresentableNameForAdmin(globals, o1).compareToIgnoreCase(UIUtils.relationPresentableNameForAdmin(globals, o2));
                }
            });
            model.setRowCount(relations.size());
            int i = 0;
            for (Relation relation : relations) {
                model.setValueAt(relation, i, 0);
                model.setValueAt(relation, i, 1);
                i++;
            }
        } catch (SQLException ex) {
            globals.addError(resourceMap.getString("MESSAGE.ErrorByFetchRelations"));
        }
    }

    static class RelationCellEditor extends AbstractCellEditor
            implements TableCellEditor {

        private RelationCellRenderer editorComponent;
        private EditorListener editorListener = new EditorListener();

        public RelationCellEditor(Globals globals) {
            editorComponent = new RelationCellRenderer(globals);
            editorComponent.setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
            for (int i = 0; i < RelationCellRenderer.buttonsCount; i++) {
                editorComponent.radioButtons[i].addActionListener(editorListener);
            }
        }

        @Override
        public Object getCellEditorValue() {
            return editorComponent.getRelation();
        }

        @Override
        public Component getTableCellEditorComponent(JTable table, Object value, boolean isSelected, int row, int column) {
            switch (column) {
                case 1:
                    if (isSelected) {
                        editorComponent.setForeground0(table.getSelectionForeground());
                        editorComponent.setBackground0(table.getSelectionBackground());
                    } else {
                        editorComponent.setForeground0(table.getForeground());
                        editorComponent.setBackground0(table.getBackground());
                    }
                    editorComponent.setRelation((Relation) value);
                    return editorComponent;
            }
            return null;
        }

        class EditorListener implements ActionListener, ItemListener, Serializable {

            @Override
            public void actionPerformed(ActionEvent e) {
                fireEditingStopped();
            }

            @Override
            public void itemStateChanged(ItemEvent e) {
                fireEditingStopped();
            }
        }
    }

    static class RelationCellRenderer extends JPanel implements TableCellRenderer {

        public static final int buttonsCount = 7;
        public final JRadioButton[] radioButtons = new JRadioButton[buttonsCount];
        public static final RelationType[] relationTypes = new RelationType[]{
            RelationType.UNKNOWN,
            RelationType.ENTITY,
            RelationType.PERIODIC,
            RelationType.GROUP,
            RelationType.INTERSECTION,
            RelationType.REFERENCE_BOOK,
            RelationType.HIDDEN};
        private final ButtonGroup group = new ButtonGroup();
        private Relation relation;
        private static final Border noFocusBorder = new EmptyBorder(1, 1, 1, 1);
        private static final Border jRadioButtonBorder = new EmptyBorder(0, 0, 0, 0);
        private static final DefaultTableCellRenderer stringRenderer = new DefaultTableCellRenderer();
        private final Globals globals;

        public RelationCellRenderer(Globals globals) {
            setLayout(new FlowLayout(FlowLayout.CENTER, 20, 0));
            this.globals = globals;
            for (int i = 0; i < buttonsCount; i++) {
                radioButtons[i] = new JRadioButton();
                group.add(radioButtons[i]);
                add(radioButtons[i]);
                radioButtons[i].setBorder(jRadioButtonBorder);
            }
        }

        public void setBackground0(Color bg) {
            super.setBackground(bg);
            for (JRadioButton rb : radioButtons) {
                rb.setBackground(bg);
            }
        }

        public void setForeground0(Color fg) {
            super.setForeground(fg);
            for (JRadioButton rb : radioButtons) {
                rb.setForeground(fg);
            }
        }

        public Relation getRelation() {
            for (int i = 0; i < buttonsCount; i++) {
                if (radioButtons[i].isSelected()) {
                    relation.setRelationType(relationTypes[i]);
                    break;
                }
            }
            return relation;
        }

        public void setRelation(Relation relation) {
            for (int i = 0; i < buttonsCount; i++) {
                if (relationTypes[i] == relation.getRelationType()) {
                    radioButtons[i].setSelected(true);
                    break;
                }
            }
            this.relation = relation;
        }

        @Override
        public Component getTableCellRendererComponent(JTable table, Object value,
                boolean isSelected, boolean hasFocus, int row, int column) {
            if (value == null) {
                return this;
            }
            Relation rel = (Relation) value;
            switch (column) {
                case 0:
                    JLabel label=(JLabel) stringRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                    label.setText(UIUtils.relationPresentableNameForAdmin(globals, rel));
                    label.setForeground(rel.getSourceType() == RelationSourceType.TABLE ? Color.BLACK : Color.GRAY);
                    return label;
                case 1:
                    if (isSelected) {
                        setForeground0(table.getSelectionForeground());
                        setBackground0(table.getSelectionBackground());
                    } else {
                        setForeground0(table.getForeground());
                        setBackground0(table.getBackground());
                    }

                    setRelation((Relation) value);

                    if (hasFocus) {
                        setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
                    } else {
                        setBorder(noFocusBorder);
                    }
                    return this;
            }
            return null;
        }
    }

    @Action
    public void forecastOne() {
        try {
            globals.getDatabaseDef().forecastRelationTypeOne();
            fillTable();
            globals.addInfo("Первое предположение сделано");
            globals.addHint("Скорректируйте отметки о ненужных таблицах и сделайте второе предположение");
        } catch (SQLException ex) {
            globals.addError("Ошибка связи с базой данных");
        }
    }

    @Action
    public void forecast2() {
        try {
            globals.getDatabaseDef().forecastRelationTypeTwo();
            fillTable();
            globals.addInfo("Второе предположение сделано");
            globals.addHint("Скорректируйте отметки сущностей и справочников, затем сделайте третье предположение");
        } catch (SQLException ex) {
            globals.addError("Ошибка связи с базой данных");
        }
    }

    @Action
    public void forecastThree() {
        try {
            globals.getDatabaseDef().forecastRelationTypeThree();
            fillTable();
            globals.addInfo("Третье предположение сделано");
            globals.addHint("Скорректируйте отметки групп, периодических атрибутов и таблиц пересечений, затем перейдите на следующую страницу");
        } catch (SQLException ex) {
            globals.addError("Ошибка связи с базой данных");
        }
    }
}
